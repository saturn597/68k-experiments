	; A program allowing the user to move a rectangle on screen with the
	; mouse. 
	
	include 'Traps.a'		; Gets us A-traps
	include 'SysEqu.a'  	; For ScrnBase


qdglobals	record 0, decrement
thePort ds.l 1
white ds.l 2
black ds.l 2
gray ds.l 2
ltGray ds.l 2
dkGray ds.l 2
arrow ds.l 17
rectRight ds.w 1
rectBottom ds.w 1
rectLeft ds.w 1
rectTop ds.w 1
rowBytes ds.w 1
baseAddr ds.l 1
randSeed ds.l 1
	org -206
	endr
	
qd ds.b qdglobals			; allocate for QuickDraw globals


drawLineHelper proc
	; Take x-coords D0.w and D1.w and y-coord D2.w. Draw a horizontal line at D2,
	; from D0 to D1. (D0 < D1). This procedure won't cross over 
	; x-coordinates that are divisible by 32. (So if going from x=29 to 50, 
	; the line will only be 3 pixels long because it'll stop before x=32).
	; If upper word of D0 is negative, draw in black.
	
	movem.l A0/D0-D7, -(SP)
	
	move.l scrnBase, A0
	; A0 contains the screen base
	
	move.l #-1, D7
	; D7 will contain the long word of individual pixels we draw

	clr.l D3
	move.w D0, D3
	divu.w #32, D3
	swap D3
	move.w D3, D4
	clr.w D3
	swap D3
	; D3 identifies the 32-bit horizontal segment we're drawing within. D4
	; is the number of pixels to the right of that segment's edge that our
	; line will start.

	lsr.l D4, D7
	not.l D7
	; D7 is now the bits we need to write to the screen. 
	; (Assuming we go all the way to the end of our 32-bit segment)

	clr.l D5
	move.w D1, D5
	divu #32, D5
	cmp.w D3, D5
	bne.s @1
	; if the right-hand coordinate we were given is in a different 32
	; bit segment, skip the next part, we'll just draw to the edge of the
	; segment.
	
	clr.w D5
	swap D5
	sub.w #32, D5
	; D5 contains the number of pixels in our line minus 32.
	
	neg.w D5
	moveq.l #0, D6
	moveq.l #1, D4
	lsl.l D5, D4
	subq.l #1, D4
	or.l D4, D7
	; Chop off the bits on the right of D7 if we're not drawing the whole
	; 32 bit segment.

	
@1
	mulu #4, D3				; Account for left x-coord
	mulu qd.rowBytes, D2	; Account for y-coord
	add.l D2, D3				
	; now D3 is the number of bytes we need to go to get from the upper
	; left of the screen to the start of the 32 pixel segment where we
	; start drawing
	
	move.l (A0, D3), D1		; D1 contains pixels where we're drawing

	swap D0
	tst.w D0
	bmi.s @2
	; Branch if we're drawing black

	not.l D1
	not.l D7
	or.l D1, D7
	not.l D7
	; leaving the area around the line unchanged

	bra.s @3
	
@2
	not.l D7
	or.l D1, D7
@3
	move.l D7, (A0, D3)		; Draw the line by writing to screen buff

	movem.l (SP)+, A0/D0-D7
	rts
	endp

	
drawLine proc
	; Draw a horizontal line from x=D0.w to x=D1.w, at y=D2.w. If upper
	; word of D0 is negative, draw in black.
	
	movem.l D0-D1, -(SP)
	
	cmp.w qd.rectRight, D1
	bmi.s @1
	move.w qd.rectRight, D1
	; Clip at right edge of screen
@1
	jsr drawLineHelper
	lsr.l #5, D0
	addq.l #1, D0
	lsl.l #5, D0
	cmp.w D0, D1
	bmi.s @2
	bra.s @1
@2
	movem.l (SP)+, D0-D1
	
	rts
	endp
	
drawRect proc
	; Draw a  rectangle at coordinates given in D0-D1, width and height in
	; D2-D3.If upper word of D0 is negative, draw in black.
	
	cmpi #0, D3				; Don't do anything if height <= 0
	ble.s @2
	
	movem.l D0-D3, -(SP)
		
	exg D1, D2
	add.w D0, D1
	subq.w #1, D3
	; We want D0 to be the left x-coord, D1 to be the right x-coord, D2
	; to be the y-coord. D3 will be our current y-coord as we loop.
		
@1
	; Draw the rectangle as a series of horizontal lines
	jsr drawLine
	addq.w #1, D2			; Increment the y-coord by 1
	dbra D3, @1				; Loop until we've drawn the whole height
	
	movem.l (SP)+, D0-D3

@2
	rts
	endp

getBitsInScreen proc
	; Returns the number of bits in the screen.
	
	move.l D1, -(SP)		; Save register D1
	
	; qd-116 contains 2 bytes for the rightmost coordinate on screen, and
	; 2 for the coordinate lowest on the screen. Multiply those together
	; to get the total number of bits. 
	move.l qd.rectRight, D1 ; Move lower right corner of screen to D1
	move.w D1, D2			; Moves low word in D1 to D2
	swap D1					; Swap high and low words in D1
	mulu.w D1, D2			; Multiply low word in both registers
	
	move.l (SP)+, D1		; Restore D1
	rts

drawPattern proc
	; Takes a word passed on the stack as a pattern. Copy that pattern
	; directly to the screen buffer.
	
	move.l (SP)+, A0		; Save the return address
	
	move.w (SP)+, D0		; Put the pattern in D0
	move.l ScrnBase, A1		; Base of screen in A1
	
	jsr getBitsInScreen		; Get the # of bits in the screen
	asr.l #4, D2			; Divide that by 16, we'll move word at a time
	sub.w #1, D2			; Our loop will go through 0
	
@1	move.w D0, (A1)+		; Move a word to the screen
	dbra D2, @1				; Do that repeatedly until D2 is 0
		
	pea (A0)				; Restore the return address
	rts
	endp


black equ -1
white equ 0

fg equ white
bg equ black

start main

frame 		record {a6Link},decr
a6Link		ds.l	1
paddleX		ds.w	1
ballX		ds.w	1
ballY		ds.w	1
ballDx		ds.w	1
ballDy		ds.w	1
ballCounter	ds.l	1
padCounter	ds.l	1
prevTicks	ds.l	1
localSize 	equ		*
	endr
	
	with frame

	link A6, #localSize
	
	pea qd.thePort			; _initGraf takes the grafPtr as a parameter
	_initGraf				; Initialize QuickDraw globals

	_hideCursor
	
	move.w #0, D0			; initialize coordinates

initializeGame
	move.l ticks, prevTicks(A6)
	move.w #bg, -(SP)		; draw background
	jsr drawPattern

	move.w #256, ballX(A6)
	move.w #100, ballY(A6)
	move.w #1, ballCounter(A6)
	move.w #1, padCounter(A6)
	clr.w ballDx(A6)
	move.w #4, ballDy(A6)

gameLoop
	move.w #300, D1			; y-coord of paddle
	move.w #100, D2			; width of paddle
	move.w #7, D3			; height of paddle
	
	;subq.w #1, padCounter(A6)
	;bne.s updateBall

	;move.w #10, padCounter(A6)
	
	move.l RawMouse, D4		; get mouse coordinates
	
	swap D0
	move.w #fg, D0
	swap D0
	cmp.w paddleX(A6), D4
	beq.s drawIt
	swap D0
	move.w #bg, D0
	swap D0
	; if the mouse has moved, draw in background color next so we 
	; erase the old paddle. Otherwise, keep the foreground color.

drawIt
	move.w paddleX(A6), D0	; draw paddle at old position
	jsr drawRect
	; Draw over paddle's previous location with background color

	move.w D4, paddleX(A6)	; mouse position is new paddle X
	
	move.w #fg, D0		
	swap D0
	move.w paddleX(A6), D0
	jsr drawRect	
	; now draw the paddle in foreground color

updateBall
	subq.w #1, ballCounter(A6)
	bne.s checkMouse
	; only redraw ball when counter hits zero
	
	move.w #1, ballCounter(A6)
	; restart counter
	
	move.l prevTicks(A6), D0
	sub.l ticks, D0
	neg.l D0
	move.w ballDx(A6), D1
	move.w ballDy(A6), D2
	mulu.w D0, D1
	mulu.w D0, D2
	move.l ticks, prevTicks(A6)
	; Calculate amount to change X and Y based on how many ticks since 
	; last update (1 tick = 1/60 sec)
	
	move.w ballX(A6), D4
	move.w ballY(A6), D5
	; Save old coords in D4, D5
	
	move.w D4, D6
	move.w D5, D7
	add.w D1, D6
	add.w D2, D7
	addq.w #7, D7				; D7 is bottom coord of ball
	cmp.w qd.rectBottom, D7
	bpl.w initializeGame
	subq.w #7, D7
	;recalc ball's position	

	move.w D6, ballX(A6)
	move.w D7, ballY(A6)
	;save ball's new position

	move.w #bg, D0
	swap D0
	move.w D4, D0
	move.w D5, D1
	move.w #7, D2
	move.w #7, D3
	jsr drawRect
	;clear previous ball
	
	move.w #fg, D0
	swap D0
	move.w D6, D0
	move.w D7, D1
	jsr drawRect
	; draw new ball
	
checkMouse
	move.b MBState, D4 
	sub.b #1, D4
	bpl.w gameLoop
	; Continue looping until mouse button clicked

end
	_ExitToShell
	end
	

