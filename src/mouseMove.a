	; A program allowing the user to move a rectangle on screen with the
	; mouse. 
	
	include 'Traps.a'		; Gets us A-traps
	include 'SysEqu.a'  	; For ScrnBase


qdglobals	record 0, decrement
thePort ds.l 1
white ds.l 2
black ds.l 2
gray ds.l 2
ltGray ds.l 2
dkGray ds.l 2
arrow ds.l 17
rectRight ds.w 1
rectBottom ds.w 1
rectLeft ds.w 1
rectTop ds.w 1
rowBytes ds.w 1
baseAddr ds.l 1
randSeed ds.l 1
	org -206
	endr
	
qd ds.b qdglobals			; allocate for QuickDraw globals

black equ -1
white equ 0

fg equ white
bg equ black

drawLineHelper proc
	; Take x-coords D0.w and D1.w and y-coord D2.w. Draw a horizontal line at D2,
	; from D0 to D1. (D0 < D1). This procedure won't cross over 
	; x-coordinates that are divisible by 32. (So if going from x=29 to 50, 
	; the line will only be 3 pixels long because it'll stop before x=32).
	; If upper word of D0 is negative, draw in black.
	
	movem.l A0/D0-D7, -(SP)
	
	move.l scrnBase, A0
	; A0 contains the screen base
	
	move.l #-1, D7
	; D7 will contain the long word of individual pixels we draw

	clr.l D3
	move.w D0, D3
	divu.w #32, D3
	swap D3
	move.w D3, D4
	clr.w D3
	swap D3
	; D3 identifies the 32-bit horizontal segment we're drawing within. D4
	; is the number of pixels to the right of that segment's edge that our
	; line will start.

	lsr.l D4, D7
	not.l D7
	; D7 is now the bits we need to write to the screen. 
	; (Assuming we go all the way to the end of our 32-bit segment)

	clr.l D5
	move.w D1, D5
	divu #32, D5
	cmp.w D3, D5
	bne.s @1
	; if the right-hand coordinate we were given is in a different 32
	; bit segment, skip the next part, we'll just draw to the edge of the
	; segment.
	
	clr.w D5
	swap D5
	sub.w #32, D5
	; D5 contains the number of pixels in our line minus 32.
	
	neg.w D5
	moveq.l #0, D6
	moveq.l #1, D4
	lsl.l D5, D4
	subq.l #1, D4
	or.l D4, D7
	; Chop off the bits on the right of D7 if we're not drawing the whole
	; 32 bit segment.

	
@1
	mulu #4, D3				; Account for left x-coord
	mulu qd.rowBytes, D2	; Account for y-coord
	add.l D2, D3				
	; now D3 is the number of bytes we need to go to get from the upper
	; left of the screen to the start of the 32 pixel segment where we
	; start drawing
	
	move.l (A0, D3), D1		; D1 contains pixels where we're drawing

	swap D0
	tst.w D0
	bmi.s @2
	; Branch if we're drawing black

	not.l D1
	not.l D7
	or.l D1, D7
	not.l D7
	; leaving the area around the line unchanged

	bra.s @3
	
@2
	not.l D7
	or.l D1, D7
@3
	move.l D7, (A0, D3)		; Draw the line by writing to screen buff

	movem.l (SP)+, A0/D0-D7
	rts
	endp

	
drawLine proc
	; Draw a horizontal line from x=D0.w to x=D1.w, at y=D2.w. If upper
	; word of D0 is negative, draw in black.
	
	movem.l D0-D1, -(SP)
	
	cmp.w qd.rectRight, D1
	bmi.s @1
	move.w qd.rectRight, D1
	; Clip at right edge of screen
@1
	jsr drawLineHelper
	lsr.l #5, D0
	addq.l #1, D0
	lsl.l #5, D0
	cmp.w D0, D1
	bmi.s @2
	bra.s @1
@2
	movem.l (SP)+, D0-D1
	
	rts
	endp
	
drawRect proc
	; Draw a  rectangle at coordinates given in D0-D1, width and height in
	; D2-D3.If upper word of D0 is negative, draw in black.
	
	cmpi #0, D3				; Don't do anything if height <= 0
	ble.s @2
	
	movem.l D0-D3, -(SP)
		
	exg D1, D2
	add.w D0, D1
	subq.w #1, D3
	; We want D0 to be the left x-coord, D1 to be the right x-coord, D2
	; to be the y-coord. D3 will be our current y-coord as we loop.
		
@1
	; Draw the rectangle as a series of horizontal lines
	jsr drawLine
	addq.w #1, D2			; Increment the y-coord by 1
	dbra D3, @1				; Loop until we've drawn the whole height
	
	movem.l (SP)+, D0-D3

@2
	rts
	endp

getBitsInScreen proc
	; Returns the number of bits in the screen.
	
	move.l D1, -(SP)		; Save register D1
	
	; qd-116 contains 2 bytes for the rightmost coordinate on screen, and
	; 2 for the coordinate lowest on the screen. Multiply those together
	; to get the total number of bits. 
	move.l qd.rectRight, D1 ; Move lower right corner of screen to D1
	move.w D1, D2			; Moves low word in D1 to D2
	swap D1					; Swap high and low words in D1
	mulu.w D1, D2			; Multiply low word in both registers
	
	move.l (SP)+, D1		; Restore D1
	rts
endp

drawPattern proc
	; Takes a word passed on the stack as a pattern. Copy that pattern
	; directly to the screen buffer.
	
	move.l (SP)+, A0		; Save the return address
	
	move.w (SP)+, D0		; Put the pattern in D0
	move.l ScrnBase, A1		; Base of screen in A1
	
	jsr getBitsInScreen		; Get the # of bits in the screen
	asr.l #4, D2			; Divide that by 16, we'll move word at a time
	sub.w #1, D2			; Our loop will go through 0
	
@1	move.w D0, (A1)+		; Move a word to the screen
	dbra D2, @1				; Do that repeatedly until D2 is 0
		
	pea (A0)				; Restore the return address
	rts
	endp

contains proc

frame 		record {a6Link}, decr
isContained	ds.w	1
params		equ		*
x1			ds.w	1
y1			ds.w	1
x2			ds.w	1
y2			ds.w	1
w			ds.w	1
h			ds.w	1
paramSize	equ		params-*
retAddr		ds.l	1
a6Link		ds.l	1
localSize	equ		*
	endr
	
	with frame
	link A6, #localSize

	move.l D0, -(SP)			; Save D0

	move.w #-1, isContained(A6)

	move.w x2(A6), D0
	cmp.w x1(A6), D0
	bpl.s end					; point is to left of rect
	
	move.w y2(A6), D0
	cmp.w y1(A6), D0
	bpl.s end					; point is above rect
	
	move.w x2(A6), D0			; D0 is right edge of rect
	add.w w(A6), D0
	cmp.w x1(A6), D0
	bmi.s end					; point is to right of right edge of rect
	
	move.w y2(A6), D0
	add.w h(A6), D0				; D0 is bottom edge of rect
	cmp.w y1(A6), D0
	bmi.s end					; point is below rect

	clr.w isContained(A6)		; isContained is true if we get here
end
	move.l (SP)+, D0			; Restore D0
	unlk A6
	movea.l (SP)+, A0
	adda.l #paramSize, SP
	jmp (A0)
	endp
	
drawBricks proc
brickW equ 64
brickH equ 7
brickXSpace equ 20
brickYSpace equ 40
brickMaxY equ 200

	movem.l D0-D3, -(SP)
	move.w #fg, D0
	swap D0
	move.w #brickXSpace, D0
	move.w #brickYSpace, D1
	move.w #brickW, D2
	move.w #brickH, D3
	
drawRow
	jsr drawRect
	add.w #brickXSpace, D0
	add.w #brickW, D0
	cmp.w qd.rectRight, D0
	bmi.s drawRow

	move.w #brickXSpace, D0
	add.w #brickYSpace, D1
	add.w #brickH, D1
	cmp.w #brickMaxY, D1
	bmi.s drawRow
end
	movem.l (SP)+, D0-D3
	rts
	endp

collision proc
frame 	record {a6Link}, decr
x		ds.w	1
y		ds.w	1
a6Link	ds.l	1
	endr
	
	endp

ballW equ 7						; ball width
ballH equ 7						; ball height

paddleW equ 100					; paddle width
paddleH equ 7					; paddle height
paddleY equ 300					; paddle Y

start main

frame 		record {a6Link},decr
a6Link		ds.l	1
paddleX		ds.w	1
ballX		ds.w	1
ballY		ds.w	1
ballDx		ds.w	1
ballDy		ds.w	1
maxX		ds.w	1
maxY		ds.w	1
minX		ds.w	1
minY		ds.w	1
ballCounter	ds.l	1
padCounter	ds.l	1
prevTicks	ds.l	1
localSize 	equ		*
	endr
	
	with frame

	link A6, #localSize
	
	pea qd.thePort			; _initGraf takes the grafPtr as a parameter
	_initGraf				; Initialize QuickDraw globals

	_hideCursor
	
	move.w #0, D0			; initialize coordinates
		
	move.w qd.rectRight, maxX(A6)
	sub.w #ballW, maxX(A6)
	move.w qd.rectLeft, minX(A6)
	add.w #ballW, minX(A6)
	move.w qd.rectBottom, maxY(A6)
	sub.w #ballH, maxY(A6)
	move.w qd.rectTop, minY(A6)
	add.w #ballH, minY(A6)

initializeGame
	move.l ticks, prevTicks(A6)
	move.w #bg, -(SP)		; draw background
	jsr drawPattern
	
	jsr drawBricks

	move.w #256, ballX(A6)
	move.w #100, ballY(A6)
	move.w #1, ballCounter(A6)
	move.w #1, padCounter(A6)
	move.w #4, ballDx(A6)
	move.w #4, ballDy(A6)

gameLoop
	move.w #paddleY, D1
	move.w #paddleW, D2
	move.w #paddleH, D3
	
	move.l RawMouse, D4		; get mouse coordinates
	
	swap D0
	move.w #fg, D0
	swap D0
	cmp.w paddleX(A6), D4
	beq.s drawIt
	swap D0
	move.w #bg, D0
	swap D0
	; if the mouse has moved, draw in background color next so we 
	; erase the old paddle. Otherwise, keep the foreground color.

drawIt
	move.w paddleX(A6), D0	; draw paddle at old position
	jsr drawRect
	; Draw over paddle's previous location with background color

	move.w D4, paddleX(A6)	; mouse position is new paddle X
	
	move.w #fg, D0		
	swap D0
	move.w paddleX(A6), D0
	jsr drawRect	
	; now draw the paddle in foreground color

updateBall
	move.l prevTicks(A6), D0
	sub.l ticks, D0
	neg.l D0
	move.w ballDx(A6), D1
	move.w ballDy(A6), D2
	muls.w D0, D1
	muls.w D0, D2
	move.l ticks, prevTicks(A6)
	; Calculate amount to change X and Y based on how many ticks since 
	; last update (1 tick = 1/60 sec)
	
	move.w ballX(A6), D4
	move.w ballY(A6), D5
	; Save old coords in D4, D5
	
	move.w D4, D6
	move.w D5, D7
	add.w D1, D6
	add.w D2, D7
	;recalc ball's position


screenBottom
	cmp.w maxY(A6), D7
	bmi.s screenTop
	neg.w ballDy(A6)
	bra.s checkMouse
screenTop
	cmp.w minY(A6), D7
	bpl.s screenLeft
	neg.w ballDy(A6)
	bra.s checkMouse
screenLeft
	cmp.w minX(A6), D6
	bpl.s screenRight
	neg.w ballDx(A6)
	bra.s checkMouse
screenRight
	cmp.w maxX(A6), D6
	bmi.s paddle
	neg.w ballDx(A6)
	bra.s checkMouse
paddle
	subq.l #2, SP
	move.w D6, -(SP)
	move.w D7, -(SP)
	add.w #ballH, (SP)				; Looking at bottom left corner of ball
	move.w paddleX(A6), -(SP)
	move.w #paddleY, -(SP)
	move.w #paddleW, -(SP)
	move.w #paddleH, -(SP)
	jsr contains
	tst.w (SP)+
	bmi.s endCollisions
	neg.w ballDy(A6)
	bra.s checkMouse
endCollisions
	; Check collisions

	move.w D6, ballX(A6)
	move.w D7, ballY(A6)
	;save ball's new position

	move.w #bg, D0
	swap D0
	move.w D4, D0
	move.w D5, D1
	move.w #ballW, D2
	move.w #ballH, D3
	jsr drawRect
	;clear previous ball
	
	move.w #fg, D0
	swap D0
	move.w D6, D0
	move.w D7, D1
	jsr drawRect
	; draw new ball
	
checkMouse
	move.b MBState, D4 
	sub.b #1, D4
	bpl.w gameLoop
	; Continue looping until mouse button clicked

end
	_ExitToShell
	end
	

