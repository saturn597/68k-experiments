	; A program allowing the user to move a rectangle on screen with the
	; mouse. 
	
	include 'Traps.a'		; Gets us A-traps
	include 'SysEqu.a'  	; For ScrnBase


qdglobals	record 0, decrement
thePort ds.l 1
white ds.l 2
black ds.l 2
gray ds.l 2
ltGray ds.l 2
dkGray ds.l 2
arrow ds.l 17
rectRight ds.w 1
rectBottom ds.w 1
rectLeft ds.w 1
rectTop ds.w 1
rowBytes ds.w 1
baseAddr ds.l 1
randSeed ds.l 1
	org -206
	endr

qd ds.b qdglobals					; allocate for QuickDraw globals


drawLine4 proc
	; Take x-coords D0 and D1 and y-coord D2. Draw a horizontal line at D2,
	; from D0 to D1. (D0 < D1). But don't cross over x-coordinates that
	; are divisible by 32. (So if going from 29 to 50, the line will only
	; be 3 pixels long).
	movem.l A0/D0-D7, -(SP)
	
	move.l scrnBase, A0
	; A0 contains the screen base
	
	move.l #-1, D7
	; D7 will contain the long word of individual pixels we draw

	clr.l D3
	move.w D0, D3
	divu.w #32, D3
	swap D3
	move.w D3, D4
	clr.w D3
	swap D3
	; D3 identifies the 32-bit horizontal segment we're drawing within. D4
	; is the number of pixels to the right of that segment's start that our
	; line will start.

	lsr.l D4, D7
	not.l D7
	; D7 is now the bits we need to write to the screen. 
	; (Assuming we go all the way to the end of our 32-bit segment)

	clr.l D5
	move.w D1, D5
	divu #32, D5
	cmp.w D3, D5
	bne.s @1
	; if the right-hand coordinate we were given is in a different 32
	; bit segment, skip the next part, we'll just draw to the edge of the
	; segment.
	
	clr.w D5
	swap D5
	sub.w #32, D5
	; D5 contains the number of pixels in our line minus 32.
	
	neg.w D5
	moveq.l #0, D6
	moveq.l #1, D4
	lsl.l D5, D4
	subq.l #1, D4
	or.l D4, D7
	; Chop off the bits on the right of D7 if we're not drawing the whole
	; 32 bit segment.

	
@1
	mulu #4, D3					; Account for left x-coord
	mulu qd.rowBytes, D2		; Account for y-coord
	add.l D2, D3				
	; now D3 is the number of bytes we need to go to get from the upper
	; left of the screen to the start of the 32 pixel segment where we
	; start drawing
	
	move.l D7, (A0, D3)			; Draw the line by writing to screen buff

	movem.l (SP)+, A0/D0-D7
	rts
	endp

drawLine2 proc
	; Draw horizontal line at y-coord D2. Go from x=D0 to x=D1, only
	; drawing up to 32 bit boundary.
	
	movem.l A0/D0-D7, -(SP)
	
	move.l scrnBase, A0
	; A0 contains the screen base
	
	move.l #-1, D7
	not.l D7
	; D7 will contain the long word of individual pixels we draw

	clr.l D6
	move.w D2, D6
	; D6 will contain our y-coord

	swap D1
	clr.w D1
	swap D1
	sub.w D0, D1
	; D1 contains the number of bits we draw
	
	move.l D1, D2
	divu.w #32, D2
	cmp.w #0, D2
	bne.s @1
	; Draw 32 bits if line > 32 bits long
	; D2 contains result of division of number of pixels by 32

	not.l D7
	clr.w D2
	swap D2  			; Make D2 just the remainder
	move.l #32, D3
	sub.l D2, D3
	lsl.l D3, D7
	not.l D7
	; D7 contains bits to draw assuming we start on a byte boundary
	
@1
	clr.l D3
	move.w D0, D3
	divu.w #8, D3
	swap D3
	move.w D3, D4
	clr.w D3
	swap D3
	; So we're D3 bytes from the left-hand side, plus remainder of D4 bits

	move.w qd.rowBytes, D5
	mulu.w D6, D5
	add.l D3, D5
	; draw at offset D5 bytes from base

	not.l D7
	lsr.l D4, D7
	not.l D7
	; D7 now contains the long word we write to screen

	move.l D7, (A0, D5)			; Draw the line
	
	movem.l (SP)+, A0/D0-D7
	rts
	endp
	
	
drawLine3 proc
@1
	jsr drawLine4
	lsr.l #5, D0
	addq.l #1, D0
	lsl.l #5, D0
	cmp.w D0, D1
	bmi.s @2
	bra.s @1
@2
	rts
	endp
	
drawRect proc

	; Draw a white rectangle at coordinates given in D0, length and
	; width given in D1.
	
	movem.l D0-D3, -(SP)
	
	move.l D1, D2
	
	move.w D0, D1
	swap D0
	
	move.w D2, D3
	swap D2

	move.w qd.rowBytes, D7

@1	move.w D0, D4
	asr #3, D4
	move.w D1, D5
	
	mulu.w D7, D5
	add.w D4, D5			; D5 gives us starting byte for writing
	
	move.l scrnBase, A0
	; move.w #256, D5
	clr.l (A0, D5)	
	
	movem.l (SP)+, D0-D3
	
	rts
	endp

getBitsInScreen proc
	; Returns the number of bits in the screen.
	
	move.l D1, -(SP)		; Save register D1
	
	; qd-116 contains 2 bytes for the rightmost coordinate on screen, and
	; 2 for the coordinate lowest on the screen. Multiply those together
	; to get the total number of bits. 
	move.l qd.rectRight, D1 ; Move lower right corner of screen to D1
	move.w D1, D2			; Moves low word in D1 to D2
	swap D1					; Swap high and low words in D1
	mulu.w D1, D2			; Multiply low word in both registers
	
	move.l (SP)+, D1		; Restore D1
	rts

drawPattern proc
	; Takes a word passed on the stack as a pattern. Copy that pattern
	; directly to the screen buffer.
	
	move.l (SP)+, A0		; Save the return address
	
	move.w (SP)+, D0		; Put the pattern in D0
	move.l ScrnBase, A1		; Base of screen in A1
	
	jsr getBitsInScreen		; Get the # of bits in the screen
	asr.l #4, D2			; Divide that by 16, we'll move word at a time
	sub.w #1, D2			; Our loop will go through 0
	
@1	move.w D0, (A1)+		; Move a word to the screen
	dbra D2, @1				; Do that repeatedly until D2 is 0
		
	pea (A0)				; Restore the return address
	rts
	endp

	
start main
	
	pea qd.thePort			; _initGraf takes the grafPtr as a parameter
	_initGraf				; Initialize QuickDraw globals
		
	move.w #$ffff, -(SP)	; Make the screen black
	jsr drawPattern
	
	;;; calling drawRect
	move.w #480, D0
	swap D0
	move.w #150, D0
	
	move.w #50, D1
	swap d1
	move.w #55, D1
	;jsr drawRect

	;; Call drawLine3
	move.w #0, D0
	move.w #512, D1
	move.w #30, D2
	jsr drawLine3


	_debugger
	
	_ExitToShell
	end
	

